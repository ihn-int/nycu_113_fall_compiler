%option never-interactive
%option nounput
%option noinput

%{
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_LINE_LEN 512
/* Code runs each time a token is matched. */
#define YY_USER_ACTION updateCurrentLine(yytext);

uint32_t line_num = 1;
uint32_t col_num = 1;
static uint32_t opt_src = 1;
static uint32_t opt_tok = 1;
static char current_line[MAX_LINE_LEN];

static void updateCurrentLine(const char *source);
static void listToken(const char *name);
static void listLiteral(const char *name, const char *literal);

%}


comma  [,]
semicolon  [\;]
colon  [:]
parentheses  \(|\)
brackets  \[|\]
delimiters  {comma}|{semicolon}|{colon}|{parentheses}|{brackets}


arithmetic  [\+\-\*\/]|"mod"
relational  [<>=]|"<="|">="|"<>"
assignment  ":="
boolean  "and"|"or"|"not"
operators  {arithmetic}|{relational}|{boolean}|{assignment}


declaration  "var"|"def"
types  "array"|"of"|"boolean"|"integer"|"real"|"string"
value  "true"|"false"
flow_control  "while"|"do"|"if"|"then"|"else"|"for"|"to"
block  "begin"|"end"
statement  "print"|"read"|"return"
reserved_words  {declaration}|{types}|{value}|{flow_control}|{block}|{statement}


identifier  [a-zA-Z][a-zA-Z0-9]*


octol  0[0-7]+
decimal  0|([1-9][0-9]*)


float  ({decimal}\.[0-9]*[1-9])|({decimal}\.0)
scientific  (([1-9][0-9]*)|({decimal}\.[0-9]*[1-9])|([1-9][0-9]*\.0))[e|E][+-]?{decimal}


char  [^\n\"]*
string  \"{char}((\"\"){char})*\"
space  [ \t\n]+

%S COMMENT NEWLINE

%%

"/*"  { BEGIN COMMENT; }

<COMMENT>[^\n]*"*/"  { BEGIN 0; }
<COMMENT>[^*\n]*  ;

"//&S-".*  { opt_src = 0; }
"//&S+".*  { opt_src = 1; }
"//&T-".*  { opt_tok = 0; }
"//&T+".*  { opt_tok = 1; }


"//"[^\n]*  { BEGIN NEWLINE; }
<NEWLINE>\n  { BEGIN 0; }

{delimiters}  { listToken(yytext); }
{operators}   { listToken(yytext); }
{reserved_words}   { char str[MAX_LINE_LEN] = "KW";
                     strcat(str, yytext);
                     listToken(str); }
{identifier}  { listLiteral("id", yytext); }
{octol}       { listLiteral("oct_integer",yytext); }
{decimal}     { listLiteral("integer", yytext); }
{float}       { listLiteral("float", yytext); }
{scientific}  { listLiteral("scientific", yytext); }
{string}      { char str[MAX_LINE_LEN]; int j = 0;
                for (int i = 1; i < (int)strlen(yytext)-1; i++) {
                    if (yytext[i] == '"' && yytext[i+1] == '"') i++;
                    str[j++] = yytext[i]; 
                }
                str[j] = '\0';
                listLiteral("string", str); }               
{space}       ;


    /* Catch the character which is not accepted by rules above */
. {
    printf("Error at line %d: bad character \"%s\"\n", line_num, yytext);
    exit(-1);
}

%%

/** @note The line is printed out and flushed when a newline character is encountered. */
static void updateCurrentLine(const char *source) {
    /* col_num is one-based */
    for (const char *c = source; *c; ++c) {
        if (*c == '\n') {
            if (opt_src) {
                printf("%d: %s\n", line_num, current_line);
            }
            ++line_num;
            col_num = 1;
            current_line[0] = '\0';
        } else {
            if (col_num < MAX_LINE_LEN) {
                current_line[col_num - 1] = *c;
                current_line[col_num] = '\0';
            } else {
                /* Truncate silently; doesn't affect the program's correctness. */
            }
            ++col_num;
        }
    }
}

static void listToken(const char *name) {
    if (opt_tok) {
        printf("<%s>\n", name);
    }
}

static void listLiteral(const char *name, const char *literal) {
    if (opt_tok) {
        printf("<%s: %s>\n", name, literal);
    }
}

/** @note This function is not required if the input file is guaranteed to end
 * with a newline. However, students may find it useful to handle the case where
 * the input file does not end with a newline, as it has been reported several
 * times in the past.
 */
int yywrap(void) {
    /* If the file is not ended with a newline, fake it to print out the last line. */
    if (col_num > 1) {
        updateCurrentLine("\n");
    }
    /* no more input file */
    return 1;
}

int main(int argc, const char **argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s [filename]\n", argv[0]);
        exit(-1);
    }

    yyin = fopen(argv[1], "r");
    if (yyin == NULL) {
        fprintf(stderr, "Open file error\n");
        exit(-1);
    }

    yylex();

    fclose(yyin);
    /* Free resources used by the scanner; otherwise, unused data structures
    will persist throughout the successive compiler phases. */
    yylex_destroy();

    return 0;
}
